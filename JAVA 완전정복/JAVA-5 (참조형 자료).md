## 5. 참조형 자료   
### 1) 배열 (1차원 배열)   
* __동일한 자료형__ 만 묶을 수 있다
* 생성시 __크기__ 를 지정 (이후 크기 변경 불가)   
<br>

### (1) 배열의 선언   
* 스택 영역(메모리)에 변수의 공간 생성   

|  | 자료형[] 변수명 | 자료형 변수명[] | 설명 |
| --- | --- | --- | --- |
| 예시 | int[] a; | int a[]; | int 자료형만 저장 가능 |
|  | double[] b; | double b[] | double 자료형만 저장 가능 |
|  | String[] c; | String c[]; | String 자료형만 저장 가능 |
<br>

#### ◇ 참조변수 값의 초기화(초기값)   
: __```null(널)```__ → 가리키는 값이 없다   
: ```int[] a = null```   
<br>
<br>

### (2-1) 배열의 객체 생성   
* 선언 : __```new 자료형[배열 길이]```__   

    * 여러 개의 값을 저장할 수 있는 공간   
    * 실제 값이 __힙(Heap) 메모리__ 에 생성   

__ex>__   
```
int[] a = new int[3]  →  정수int 3개를 저장할 수 있는 배열 객체(공간) 생성

int[] a;
a = new int[3];
```

#### ◇ new 키워드   
* "Heap 메모리에 넣어라"의 의미   
<br>

### (2-2) 배열 객체의 값 대입   
* 선언 : __```참조 변수명[인덱스] = 값```__   

__ex>__   
```
int[] a = new int[3];   // 정수 3개 크기 배열 객체 생성
a[0] = 3;               // 0번째 값 3
a[1] = 4;               // 1번째 값 4
a[2] = 5;               // 2번째 값 5

System.out.println(a[0]); → 3
```
<br>

### (2-3) 다양한 배열 선언   
#### ① 기본 자료형 배열
* 기본 자료형을 가지고 있는 참조 자료형 배열

```
boolean[] array5 = new boolean[3];   // 참/거짓 자료형 배열
int[] array6 = new int[5];         // 정수 자료형 배열
double[] array7 = new double[7];   // 실수 자료형 배열
```

#### ② 참조 자료형 배열
* 참조 자료형을 가지고 있는 참조 자료형 배열

```
String[] array8 = new String[9];   // 문자열 자료형 배열
```
<br>
<hr>

### (3) 배열 생성의 다양한 방법   
#### ① 방법1: 기본 방법
* 장점: 처음 넣어야 할 값이 지정되지 않았을 때, 미리 방을 만들어둘 수 있음
```
자료형[] 참조변수명 = new 자료형[배열의 길이]  // 배열 생성(선언)

참조변수명[0] = 값;                           // 값 대입
참조변수명[1] = 값;
```

__ex>__
```
int[] a = new int[2];
a[0] = 3;
a[1] = 4;
```

#### ② 방법2: 배열 객체의 생성 및 갑 대입
* 배열의 길이를 넣지 않음
* "배열 선언"과 "값 대입"이 분리됨
```
자료형[] 참조변수명 = new 자료형[] {값, 값 ... 값};
```

__ex>__   
```
int[] a = new int[]{3, 4, 5};
```

#### ③ 방법3: 대입할 값만 입력   
* "배열 선언"과 "값 대입"이 분리되지 X
```
자료형[] 참조변수명 = {값, 값 ... 값};
```

__ex>__   
```
int[] a = {3, 4, 5};

int[] a;       → 이런 식으로 분리될 수는 
a = {3, 4, 5}
```

<br>
<hr>

### (4) 배열 객체의 값 초기화   
#### ◆ Stack 메모리의 초기값
* 초기값을 부여하지 않는 경우 __빈칸__ 으로 존재 (읽기 불가능)   

__ex>__   
* ```int a;``` → stack 메모리에 공간 생성 (빈칸)   
<br>

#### ◇ Heap 메모리의 초기값   
* 빈칸으로 존재할 수 없으며, 디폴트 초기값이 강제 설정   
   * 기본 자료형: 숫자 디폴트값 0 (실수 0.0) / boolean 디폴트값 false
   * 참조 자료형: 디폴트값 null

__ex1>__   
* ```String[] a = new String[3];``` → 3개 공간에 각각 __null__ 이 들어감

__ex2>__   
```
* 출력 불가
int a;
int[] b;

* 출력 가능
int a = 0;              // 0으로 초기화
int[] b = null;         // null로 초기화, null이 객체를 가리키지 않음
System.out.println(a);
System.out.printlnO(b);
```
<br>
<hr>

### (5) 참조 자료형으로서 배열의 특징   
* '='는 stack 메모리 값을 복사

#### ① 기본 자료형 변수 복사: ```값의 복사```  
__ex>__   
```
int a = 3;              // stack 메모리값 3
int b = a; 
b = 7;                  // b를 7로 변경

System.out.println(a);  // 3  → a의 값을 복사한 것이기에 b를 바꿔도 a에 영향 X
System.out.println(b);  // 7
```

#### ② 참조 자료형 변수 복사: ```위치(번지) 복사```   
__ex>__   
```
int[] a = {3, 4, 5};       // "3, 4, 5"는 Heap 메모리에 저장된 위치
int[] b = a;               // a와 b 모두 같은 객체(위치)를 가리키고 있음 
b[0] = 7;

System.out.println(a[0]);  // 7  → a와 b 모두 같은 객체를 가리키고 있기에, b의 값을 바꾸면 a의 값도 바뀜
System.out.println(b[0]);  // 7
```
<br>
<hr>

### (6-1) 반복문을 이용해 배열 데이터 읽기   
* 선언 : __```배열의 길이 = 참조변수명.length```__   

__ex>__   
```
int[] a = new int[] {3, 4, 5, 6, 7};
System.out.println(a.length);          // 5
```
<br>

### ◆ for 반복문 이용   
```
int[] a = new int[100];
a[0] = 1, a[1] = 2, ..., a[99] = 100;

for (int i=0; i < a.length; i++) {     // 배열 길이 100, 인덱스는 99까지이니 i < a.length
     System.out.println(a[i]);
}
```

### ◆ for-each 반복문 이용   
* 묶음에서 데이터를 하나씩 꺼내는 것
* 선언
```
for (원소자료형 변수 : 묶음 참조자료형) {
}
```

__ex>__   
```
int[] a = new int[100];                // a 배열은 참조자료형 변수
a[0] = 1, a[1] = 2, ..., a[99] = 100;

for (int k : a) {                      // a 배열에서 1부터 꺼내서 int k에 저장
     System.out.println(k);            // int k는 꺼낸 데이터를 저장할 공간
}
```

### ★ Tip   
* __```Arrays.toString(1차원 배열)```__   
   * 배열값 출력 정적 메서드
   * 1차원 배열을 정렬해서 한번에 출력해줌

__ex>__   
```
System.out.println(Arrays.toString(new int[]{1, 2, 3});   // [1,2,3]
```
<br>

### (6-2) 배열에 원소값을 대입하는 방법   
